{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Boardfarm","text":"<p>Boardfarm is an open-source IT automation framework purely written in Python (3.11+).</p> <p>Its primary focus revolves around systems configuration, infrastructure deployment, and orchestration of advanced IT tasks such as Subscriber Provisioning, Line Termination System bootups (LTS) or a CPE firmware flash via bootloader.</p> <p>It empowers its users with the ability to automate and comprehensively test their devices across a wide range of target environments.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Boardfarm was initially developed at Qualcomm to automate testing of OpenWrt routers and other embedded devices.</p> <p></p> <p>Over time, the framework evolved to support RDK-B derived boards and IoT devices, along with the essential OSS and back-office components necessary for simulating a Telecom Service Providers' environment.</p> <p></p> <p>The operation of a device or the configuration of a server can vary depending on the specific hardware variant or the infrastructure layout of the deploying Telecom Operator.</p> <p>To address this variability, Boardfarm utilizes Pluggy to introduce a hook structure that enables its users to register customized code through plugins for each individual infrastructure component.</p> <p>This structure also enforces a uniform API specification, allowing plugins to invoke their implementation at any of the predefined checkpoints within the Boardfarm's execution cycle, offering flexibility and extensibility.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Modular Hook definitions enabling users to independently initiate the bootup/deployment process for each component within the infrastructure, offering granular control and flexibility.</li> <li>Seamless integration with Pytest. Provides easy access to devices along with their pre-set operations through protocol-specific libraries.</li> <li>A versatile connection manager that abstracts physical device connections, offering a unified set of APIs for RS232, SSH, Telnet, SNMP, and HTTP(s) communication with the infrastructure.</li> <li>A library of device templates (Python ABCs) that can be inherited and customized for implementing hardware interactions without application or server specific constraints.</li> <li>A plugin architecture that enables vendors and OEMs to perform testing and provisioning on their firmware builds/devices, whether in a predefined production or fully simulated test environment.</li> <li>Integration with Docker/QEMU to simulate various test environments and devices.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Run the following command to directly install the package from the repo:</p> <pre><code>pip install git+https://github.com/lgirdk/boardfarm.git@boardfarm3\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>boardfarm -h\n</code></pre> <p>This will display help for the framework. Here are all the switches it supports.</p> <pre><code>usage: boardfarm [-h] --board-name BOARD_NAME --env-config ENV_CONFIG --inventory-config INVENTORY_CONFIG [--legacy] [--skip-boot] [--skip-contingency-checks] [--save-console-logs]\n\noptions:\n  -h, --help            show this help message and exit\n  --board-name BOARD_NAME\n                        Board name\n  --env-config ENV_CONFIG\n                        Environment JSON config file path\n  --inventory-config INVENTORY_CONFIG\n                        Inventory JSON config file path\n  --legacy              allows for devices.&lt;device&gt; obj to be exposed (only for legacy use)\n  --skip-boot           Skips the booting process, all devices will be used as they are\n  --skip-contingency-checks\n                        Skip contingency checks while running tests\n  --save-console-logs   Save console logs to the disk\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For full documentation, including installation, tutorials and architecture overview and how to run a prplOS demo with  a CPE, ACS, lan, wan devices, please see the following.</p> <p>Boardfarm Read the Docs</p>"},{"location":"#changelog","title":"Changelog","text":"<p>Consult the CHANGELOG page for fixes and enhancements of each version.</p>"},{"location":"#license","title":"License","text":"<p>Distributed under the terms of the Clear BSD License, Boardfarm is free and open source software.</p>"},{"location":"architecture/","title":"Overview","text":""},{"location":"architecture/#introduction","title":"Introduction","text":"<p>End-to-end (E2E) solutions for CPE, access and back-office stacks are inherently complex:</p> <ul> <li>they depend on many different components (CPE, ACS, DHCP, SIP, OSS/BSS, emulators, etc.),</li> <li>span multiple layers of integration,</li> <li>involve multi-vendor delivery, and</li> <li>evolve at varying development cadences with many transitive dependencies.</li> </ul> <p>At every integration level, each incremental change must be validated against multiple, evolving target deployment environments:</p> <ul> <li>different customers run different topologies and component versions,</li> <li>each environment changes over time, and</li> <li>late discovery or poor reproducibility of environment differences drives up cost and delays.</li> </ul>"},{"location":"architecture/#the-vendorteam-challenge","title":"The vendor/team challenge","text":"<p>Vendors and engineering teams must simultaneously:</p> <ul> <li>deliver new functionality,</li> <li>design, build, integrate and validate features, and</li> <li>avoid regressions \u2014 which requires large amounts of regression testing.</li> </ul> <p>To be effective, development and validation must happen against the relevant environments: using the particular versions and configurations of the neighbouring components that exist in a real E2E deployment.</p>"},{"location":"architecture/#architecture","title":"Architecture","text":"<p>Boardfarm\u2019s architecture is designed to address these realities by emphasizing:</p> <p></p> <ul> <li>Top-down (inward) dependencies only \u2014 stable, inner layers define contracts; outer layers implement them.</li> <li>Non-restrictive API standardization \u2014 provide clear, compact templates (ABCs) so use cases and tests stay vendor-agnostic.</li> <li>Maximized portability \u2014 make each layer easy to reuse across customers and testbeds.</li> <li>Extensibility via plugins \u2014 add new device classes, transports or behaviors as plugins rather than changing the core.</li> </ul>"},{"location":"architecture/#how-this-is-achieved","title":"How this is achieved","text":"<ul> <li>Templates (ABCs) define stable device APIs that use cases and hooks rely on.</li> <li>Concrete device classes implement those templates for vendors, emulators or transports.</li> <li>Pluggy (plugin manager + hooks) orchestrates multi-phase provisioning and lifecycle events across the infrastructure (boot, configure, attach, etc.).</li> <li>Use Cases protocol-specific, test-facing operations; the API tests and the interactive shell use.</li> </ul> <p>Together, these principles make Boardfarm a portable, testable framework that helps teams develop, validate and debug E2E functionality against representative, reproducible environments while minimizing the cost of integrating multi-vendor stacks.</p>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#templates-abcs","title":"Templates (ABCs)","text":"<p>What they are: Python Abstract Base Classes that describe the minimal set of methods a device must offer for Boardfarm use cases to work.</p> <p>Why they matter: Use cases and hooks import these Templates, not concrete device classes. That guarantees portability: a test calls the template API, not vendor-specific code.</p> <p>Example sketch:</p> <pre><code>from abc import ABC, abstractmethod\n\nGpvInput = Union[str, list[str]]\nGpvStruct = dict[str, Union[str, int, bool]]\nGpvResponse = list[GpvStruct]\n\nclass ACS(ABC):\n    \"\"\"Boardfarm ACS device template.\"\"\"\n\n    @abstractmethod\n    def GPV(\n        self,\n        param: GpvInput,\n        timeout: int | None = None,\n        cpe_id: str | None = None,\n    ) -&gt; GpvResponse:\n        ...\n\n    ... # rest of the API definition\n</code></pre> <p>Guidelines:</p> <ul> <li>Keep signatures high-level and stable.</li> <li>Add capabilities via optional mixins or new ABCs rather than changing existing method signatures.</li> <li>Document expected return types and exceptions.</li> </ul>"},{"location":"architecture/#devices-concrete-implementations","title":"Devices (Concrete implementations)","text":"<p>What they are: Classes that implement a Template (ABC). They translate Template methods into transport-specific actions (SSH, serial, HTTP, local command, docker exec, QEMU socket, etc.).</p> <p>Important: Device classes may also implement device hooks (<code>hookspecs</code>) to participate in the boot/provision lifecycle \u2014 but those hook implementations should only call the templated APIs and perform device-specific I/O. Avoid exposing these vendor-specific private APIs to use cases.</p> <p>Example:</p> <pre><code>from boardfarm3.templates.acs import ACS, GpvInput, GpvResponse\n\nclass GenieACS(ACS):\n\n    def GPV(\n        self,\n        param: GpvInput,\n        timeout: int | None = None,\n        cpe_id: str | None = None,\n    ) -&gt; GpvResponse:\n        \"\"\"Send GetParamaterValues command via ACS server.\"\"\"\n        quoted_id = quote('{\"_id\":\"' + cpe_id + '\"}', safe=\"\")\n        self._request_post(\n            endpoint=\"/devices/\" + quote(cpe_id) + \"/tasks\",\n            data=self._build_input_structs_gpv(param),\n            conn_request=True,\n            timeout=timeout,\n        )\n        response_data = self._request_get(\n            \"/devices\"  # noqa: ISC003\n            + \"?query=\"\n            + quoted_id\n            + \"&amp;projection=\"\n            + self._build_input_structs(param),\n            timeout=timeout,\n        )\n        return GpvResponse(self._convert_response(response_data))\n\n    ... # rest of the implementation\n\n</code></pre> <p>Rules:</p> <ul> <li>Devices are only meant to drive I/O and vendor-specific quirks.</li> <li>Do not implement business logic in devices \u2014 they will always be implemented in use cases.</li> </ul>"},{"location":"architecture/#use-cases","title":"Use Cases","text":"<p>What they are: The library of testable, protocol-specific operations.</p>"},{"location":"architecture/#why-use-cases","title":"Why use cases?","text":"<ul> <li>Tests call use cases (e.g., GPV, flash_firmware) rather than device methods directly.</li> <li>Use cases hide which concrete device handles the operation \u2014 the Template contract ensures compatibility.</li> </ul> <p>Example:</p> <pre><code>\"\"\"TR-069 Use cases.\"\"\"\n\nfrom __future__ import annotations\n\nif TYPE_CHECKING:\n    from boardfarm3.templates.acs import ACS\n    from boardfarm3.templates.cpe import CPE\n\ndef get_parameter_values(\n    params: str | list[str],\n    acs: ACS,\n    board: CPE,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Perform TR-069 RPC call GetParameterValues.\"\"\"\n\n    return acs.GPV(params, cpe_id=board.sw.tr69_cpe_id)\n</code></pre> <p>Example usage (in IPython or pytest):</p> <pre><code>from boardfarm3.use_cases.tr069 import get_parameter_values\nfrom boardfarm3.templates.acs import ACS\nfrom boardfarm3.templates.cpe import CPE\n\nfrom boardfarm3.lib.device_manager import DeviceManager\n\nvalue = get_parameter_value(\n    'Device.DeviceInfo.Manufacturer',\n    device_manager.get_device_by_type(ACS),\n    device_manager.get_device_by_type(CPE),\n    )\n</code></pre>"},{"location":"architecture/#summary","title":"Summary","text":"<ul> <li>Stable contract (Template/ABC) \u2014 The ACS template (an ABC) declares the <code>GPV</code>(...) -&gt; <code>GpvResponse</code> API and the expected input/output types.</li> <li>Dependency inversion \u2014 Use cases (<code>get_parameter_values</code>) accept an ACS instance (the interface) rather than a concrete class.</li> <li>Pluggable device implementations \u2014 Concrete classes like <code>GenieACS</code> implement the ACS ABC and provide transport/vendor-specific logic.</li> <li>Runtime selection via DeviceManager \u2014 Tests call <code>device_manager.get_device_by_type(ACS)</code> to obtain any registered ACS device. The test code doesn\u2019t change when you swap GenieACS for AxirosACS (or a simulator).</li> <li>Easy mocking &amp; CI-friendly \u2014 You can inject fakes or mocks that implement the ACS interface for fast, deterministic unit tests and CI runs without hardware.</li> </ul> <p>Result: tests written against the ACS template are vendor-agnostic \u2014 you can run the same test suite against real hardware, vendor servers, or simulated ACS backends without changing test code.</p>"},{"location":"architecture/#hooks-specification-and-pluggy","title":"Hooks Specification and Pluggy","text":"<p>Boardfarm uses Pluggy as the central plugin manager. Pluggy provides the extension points (<code>@hookspecs</code>) that let different repositories register device classes, extend runner behaviour, and participate in the multi-phase environment boot/provision lifecycle. The design principle is simple:</p> <ul> <li>Framework (core) concerns are exposed as <code>core hooks</code> \u2014 used to customize runner behavior (CLI args, config parsing, device reservation, environment setup, device registration, release and shutdown).</li> <li>Device concerns are expressed as <code>device hooks</code> \u2014 implemented by concrete device classes (plugins) to perform boot, configuration, validation and shutdown for that device.</li> <li>The runner invokes core hooks to orchestrate the run; core hooks in turn cause the runner to call device hooks for each device in the configured order.</li> </ul>"},{"location":"architecture/#hook-categories-where-they-belong","title":"Hook categories &amp; where they belong","text":"<p>Core hooks (framework-level) \u2014 implemented by runner or plugin authors. These orchestrate the overall lifecycle of a run:</p> <ul> <li><code>boardfarm_add_cmdline_args(argparser)</code> \u2014 add CLI flags.</li> <li><code>boardfarm_parse_config(...) -&gt; BoardfarmConfig</code> (firstresult) \u2014 produce/override the merged run config.</li> <li><code>boardfarm_reserve_devices(...) -&gt; inventory</code> (firstresult) \u2014 reserve lab hardware before deployment.</li> <li><code>boardfarm_setup_env(...) -&gt; DeviceManager</code> (firstresult) \u2014 deploy devices and build the <code>DeviceManager</code>.</li> <li><code>boardfarm_register_devices(...) -&gt; DeviceManager</code> (firstresult) &amp; <code>boardfarm_add_devices()</code> \u2014 register device classes (map inventory <code>\"type\"</code> \u2192 class).</li> <li><code>boardfarm_release_devices(...)</code> &amp; <code>boardfarm_shutdown_device()</code> \u2014 release reserved devices and perform framework cleanup.</li> </ul> <p>Device hooks (device-level) \u2014 implemented by device authors (usually as <code>@hookimpl</code> instance methods on concrete device classes). These drive device-specific behavior within the lifecycle:</p> <ul> <li><code>boardfarm_skip_boot</code> \u2014 initialize/attach to device without provisioning.</li> <li><code>boardfarm_server_boot</code> / <code>boardfarm_device_boot</code> / <code>boardfarm_attached_device_boot</code> \u2014 boot device categories in sequence.</li> <li><code>boardfarm_server_configure</code> / <code>boardfarm_device_configure</code> / <code>boardfarm_attached_device_configure</code> \u2014 apply environment-driven configuration.</li> <li><code>contingency_check(env_req, device_manager)</code> \u2014 per-test health check used by pytest integration.</li> <li><code>*_async</code> variants \u2014 available where concurrency helps speed up provisioning.</li> </ul>"},{"location":"architecture/#device-categories","title":"Device categories","text":"<p>A Boardfarm device should be one of:</p> <ol> <li>server \u2014 infrastructure services (ACS, DHCP, SIP, etc.).</li> <li>device \u2014 main DUTs/CPEs that depend on infrastructure.</li> <li>attached device \u2014 clients attached to devices (LAN clients, phones, etc.).</li> </ol> <p>Each category participates in different lifecycle phases and must implement hooks appropriate to that category.</p>"},{"location":"architecture/#execution-order","title":"Execution order","text":"<p>When boot is enabled, Boardfarm executes device hooks in this order (each name is an actual <code>@hookspec</code>):</p> <pre><code>boardfarm_server_boot\n\u2193\nboardfarm_server_configure\n\u2193\nboardfarm_device_boot\n\u2193\nboardfarm_device_configure\n\u2193\nboardfarm_attached_device_boot\n\u2193\nboardfarm_attached_device_configure\n</code></pre>"},{"location":"architecture/#minimal-checklist-for-architecture-readers","title":"Minimal checklist for architecture readers","text":"<ul> <li>Core hooks extend and orchestrate the runner; device hooks implement per-device behavior.</li> <li>Use cases depend on Templates (ABCs) only \u2014 device implementations plug in behind the Templates via hooks.</li> <li>The runner uses core hooks to build the environment and then calls device hooks in the documented order.</li> <li>See the dedicated \u201cHow to implement\u201d page for step-by-step examples (device skeletons, core hook examples, tests and best practices).</li> </ul>"},{"location":"architecture/#execution-order-comprehensive-view","title":"Execution Order (Comprehensive View)","text":"<p>The following diagram explains in brief the execution lifecycle of the boardfarm runner: </p>"},{"location":"changelog/","title":"CHANGELOG","text":""},{"location":"changelog/#2022110-2022-03-16","title":"2022.11.0 (2022-03-16)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>devices:board_templates.py,mib_template.py,linux.py: add mib template to support vendor specific mib configurations for software download</li> <li>networking.py: add dns_resolve  uc</li> <li>device_getters.py: add provisioner getter</li> <li>voice.py: remove sleep from disconnect_the_call</li> <li>traffic_gen return TrafficGeneratorResults</li> </ul>"},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>linux.py: change regular expression to get process id</li> <li>quagga_router.py: update ip route method to fetch route from quagga instance</li> </ul>"},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>debian_lan.py: validate ipv6 address is obtained and throw exception</li> </ul>"},{"location":"changelog/#2022090-2022-03-02","title":"2022.09.0 (2022-03-02)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>debian_isc.py: add support for invalid dhcp gateway</li> <li>add get_load_avg to sw template</li> <li>debian: fetch DNS entry from inventory json and update in dnsmasq.conf</li> <li>linux.py: add graceful error handling</li> <li>linux: add support for ping using json cli</li> <li>add 2.19 env version</li> <li>boardfarm:use_cases:networking.py: write a use case to parse ICMP responses and compare</li> </ul>"},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>voice.py: reduce sleep time in makecall</li> <li>quagga_router.py: update atexit call and docstrings</li> </ul>"},{"location":"changelog/#breaking-change","title":"BREAKING CHANGE","text":"<ul> <li>Do not merge until all the executors have been updated! BOARDFARM-1698</li> <li>BOARDFARM-1500</li> </ul>"},{"location":"changelog/#2022070-2022-02-16","title":"2022.07.0 (2022-02-16)","text":""},{"location":"changelog/#refactor_1","title":"Refactor","text":"<ul> <li>pyproject.toml: freeze selenium dependency to 4.1.0</li> </ul>"},{"location":"changelog/#feat_2","title":"Feat","text":"<ul> <li>quagga_router.py: add quagga router device class</li> <li>linux.py: add support for tcpdump capture,read[tcpdump,tshark]</li> <li>traffic_generator.py: formalise traffic generator template</li> <li>debian_lan: add iw and wpasupplicant packages in image</li> </ul>"},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>pyproject.toml: freeze pyvirtualdisplay package version to 2.2</li> <li>pyproject.toml: pin elasticsearch to stay compliant with api</li> <li>increase cli size</li> </ul>"},{"location":"changelog/#2022050-2022-02-02","title":"2022.05.0 (2022-02-02)","text":""},{"location":"changelog/#feat_3","title":"Feat","text":"<ul> <li>devices:softphone.py,debian_fxs.py: implement enable_call_waiting and enable_call_forwarding_busy use cases for softphone</li> <li>getters.py: add getters for lan and wan clients</li> </ul>"},{"location":"changelog/#fix_3","title":"Fix","text":"<ul> <li>lib:voice.py: fix _parse_rtp_trace usecase to check for rtp packets associated to a SIP setup-frame</li> <li>debian_wan: replace google.com with wan.boardfarm.com for v4 and v6</li> <li>debian_fxs: update debian:stable-slim with debian:buster-slim</li> <li>connection_decider: use strict match for connection type</li> <li>pyproject.toml: pin dependency for selenium version 3.141.0</li> <li>devices:debian_lan.py: set icmp_echo_ignore_broadcasts to false on lan devices</li> <li>boardfarm:lib:voice: fix _parse_rtp_trace when start and end indexes are same</li> </ul>"},{"location":"changelog/#2022030-2022-01-20","title":"2022.03.0 (2022-01-20)","text":""},{"location":"changelog/#feat_4","title":"Feat","text":"<ul> <li>devices:softphone.py: implement the unimplemented usecases for softphone</li> <li>add connect to DUT via ssh</li> <li>device-manager: register wifi devices</li> </ul>"},{"location":"changelog/#fix_4","title":"Fix","text":"<ul> <li>devices:softphone.py: fix softphone pjsip config to disable TCP transport</li> <li>networking.py: add link_local_ipv6 to IPAddresses dataclass</li> <li>devices:linux.py: fix get_interface_ipaddr to handle AttributeError and throw PexpectTimeoutError</li> <li>devices:debian_isc.py: fix for port number of acs url in vendor specific dhcp configuration</li> <li>debian: updated pkgs that can be installed</li> <li>fixes to run with debian:buster-slim image</li> <li>debian: fix pexpect xterm env set</li> <li>installers: minor fix on apt_install</li> </ul>"},{"location":"changelog/#breaking-change_1","title":"BREAKING CHANGE","text":"<ul> <li>BOARDFARM-1456</li> </ul>"},{"location":"changelog/#2022010-2022-01-05","title":"2022.01.0 (2022-01-05)","text":""},{"location":"changelog/#feat_5","title":"Feat","text":"<ul> <li>get image use image_uri</li> <li>multicast: add multicast usecases</li> <li>quagga: add mrouted daemon</li> </ul>"},{"location":"changelog/#breaking-change_2","title":"BREAKING CHANGE","text":"<ul> <li>If using Docsis devices the latest Docsis change must be picked.</li> </ul>"},{"location":"changelog/#fix_5","title":"Fix","text":"<ul> <li>boardfarm:resources:configs:kamailio.cfg: update kamailio.cfg to configure timeout of 25sec</li> <li>boardfarm:devices:debian_isc.py: fix acs url in vendor specific dhcpoptions to use http as prefix</li> <li>boardfarm:use_cases:voice.py: handle exception for hangup in shutdown_phone usecase</li> </ul>"},{"location":"changelog/#2021510-2021-12-22","title":"2021.51.0 (2021-12-22)","text":""},{"location":"changelog/#fix_6","title":"Fix","text":"<ul> <li>devices:linux.py: add fix to fetch erouter0/lan ipv6 on linux console when output is delayed/untidy after command execution</li> <li>do not use get_pytest_name yet</li> <li>fix test name fetching in acs intercept</li> <li>devices:debian_lan.py: handle timeout error when tshark read is too long for failed lan renewal</li> </ul>"},{"location":"changelog/#feat_6","title":"Feat","text":"<ul> <li>quagga-pim: add IGMP multicast routing for interface</li> <li>enable/disable acs pcap capture</li> <li>improved name discovery</li> </ul>"},{"location":"changelog/#2021490-2021-12-09","title":"2021.49.0 (2021-12-09)","text":""},{"location":"changelog/#feat_7","title":"Feat","text":"<ul> <li>use_cases:voice.py: add place_call_offhook use case for voice</li> <li>networking.py: Add IPAddresses data class for erouter use case at common location</li> <li>use_cases:voice.py: add off hook use case for voice</li> </ul>"},{"location":"changelog/#fix_7","title":"Fix","text":"<ul> <li>lib:dhcpoption.py: fix ManufacturerOUI under DHCP Option 125 on LAN side</li> <li>pylint: Add pylint config and fix pylint issues.</li> </ul>"},{"location":"changelog/#2021470-2021-11-24","title":"2021.47.0 (2021-11-24)","text":""},{"location":"changelog/#fix_8","title":"Fix","text":"<ul> <li>lib:voice.py: add 1 second delay to verify RTP packets and handle few exceptions</li> </ul>"},{"location":"changelog/#2021460-2021-11-18","title":"2021.46.0 (2021-11-18)","text":""},{"location":"changelog/#feat_8","title":"Feat","text":"<ul> <li>pyproject.toml: Add commitizen-specific config. Prune tbump config.</li> <li>pyproject.toml: Add tbump config and bump version manually.</li> <li>boardfarm/bft: Add option to skip resource reservation status check on Jenkins</li> <li>linux.py: Add hostname property for all linux devices.</li> <li>remove zephyr dead code</li> <li>devices:debian_fxs.py,softphone.py: fix and implement sip abstract methods</li> <li>use_cases:networking.py: add use_cases to be used by TCs to avoid direct access to board consoles</li> <li>lib:linux_nw_utility.py,linux_console_utility.py: add network and dut console utilities</li> <li>bft,lockableresources: Use Jenknins Lockable Resources in Boardfarm to manage modems</li> <li>quagga: dockerfile for quagga router</li> <li>installers.py: add method get_interface_private_ip6addr</li> <li>networking.py-wifi.py-wifi_template.py: add wifi usecases</li> <li>acs: show console interactions</li> <li>voice: add voice conference use cases</li> <li>devices-base_devices-board_template: add FXO as voice</li> <li>devices:-base_devices:-fxo_template: add new template class to be used by MTA template</li> <li>use_cases/snmp.py: Add basic generic snmp use cases (wrappers around SNMPv2).</li> <li>platform/debian: lighttpd and tftpd use the same directory</li> <li>Add generic scp command implementation to linux device.</li> </ul>"},{"location":"changelog/#fix_9","title":"Fix","text":"<ul> <li>resources:configs:kamailio.cfg: configure kamailio to send \"181 Call is Being Forwarded\" packet on call forward busy</li> <li>debian_fxs: remove reply with code implementation</li> <li>devices:softphone.py: hardening of the phone_config and phone_start of softphone device to fix issues</li> <li>lib,use_cases:voice.py: add new use cases for sipserver/voice rtp, remove the legacy ones and add support for media attribute, connection info check</li> <li>devices:debian_fxs,devices:kamailio: harden the implementations of fxs and sip server devices</li> <li>devices:debian_isc.py: provide a different acs url from config file both for v4 and v6 when dhcp vendor options are configured</li> <li>common.py: split send_to_influx further into validate_influx_connection</li> <li>change gui resolution to 1920x1080</li> <li>influx_db_helper.py: add timeout parameter to influx db connection request</li> <li>lockableresources.py: Fix wifi enclosure device selection based on board type</li> <li>lib:installers.py: add recovery solution when acs server console is hung during apt install</li> <li>devices/serialphone.py: modify the wrapper function exit_python_on_exception</li> <li>use_cases: fix docstrings to make sphinx happy</li> <li>kamailio.cfg: modify configurations to use nonce value only once for authentication</li> <li>quagga: add natting on router</li> <li>lib/common.py: remove unused self argument from configure_ovpn. Return bool success value</li> <li>installers.py: add fix for openvpn ipv6 server connection</li> <li>implement-voice-conference-APIs: derive implementation for Voice conference call signatures</li> <li>devices-base_devices-sip_template: update signatures</li> <li>env_helper.py: handle scenarios with list of dictionaries and list of strings in env request validation</li> <li>installers.py: add print statements instead of debug for lan client IRC scripts</li> <li>fix pylint errors</li> <li>Do not restart interface twice during CC. Flush tcpdump buffer before kill</li> </ul>"},{"location":"changelog/#refactor_2","title":"Refactor","text":"<ul> <li>linux.py: return dhcp renew output</li> <li>axiros_acs: fix the interface name</li> <li>axiros_acs: add acs aux iface name</li> <li>change lib to docsis_lib globally</li> </ul>"},{"location":"development/","title":"Development (How-to-Guide)","text":""},{"location":"development/#writing-a-boardfarm-plugin","title":"Writing a Boardfarm plugin","text":"<p>A Boardfarm plugin project typically follows the convention <code>boardfarm_&lt;plugin_name&gt;</code> and contains a small, focused set of packages that implement devices, plugin registration, templates, use cases and shared libraries.</p> <p>Note: below I use DeviceA as a generic device implementation name. Replace DeviceA and  with your concrete names. <pre><code>boardfarm_&lt;plugin_name&gt;/\n\u251c\u2500\u2500 devices/             # concrete device implementations (classes)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 device_a.py\n\u251c\u2500\u2500 plugins/             # modules that register to the plugin manager (hookimpl)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 registration.py\n\u251c\u2500\u2500 templates/           # optional: extra Template ABCs (vendor/plugin-specific)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 custom_template.py\n\u251c\u2500\u2500 use_cases/           # optional: plugin-level use cases\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 provisioning.py\n\u251c\u2500\u2500 lib/                 # helper libraries reused by devices / use cases\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 helpers.py\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"development/#directory-roles","title":"Directory roles","text":"<ul> <li><code>devices/</code> \u2014 Concrete implementations of templates (e.g. <code>DeviceA</code>). These classes will be instantiated by Boardfarm (via <code>DeviceManager</code>) when inventory entries reference your <code>type</code>.</li> <li><code>plugins/</code> \u2014 Module(s) that export <code>@hookimpl</code> functions such as <code>boardfarm_add_devices()</code>, <code>boardfarm_add_cmdline_args()</code>, <code>boardfarm_setup_env()</code>, etc. These make your package discoverable to Boardfarm and Pluggy.</li> <li><code>templates/</code> \u2014 (optional) Plugin-specific additional ABCs or mixins. Prefer extending the main boardfarm repo templates where possible.</li> <li><code>use_cases/</code> \u2014 (optional) Higher-level plugin logic composed from template methods (for internal tests or helper scripts).</li> <li><code>lib/</code> \u2014 Shared utilities used by your device drivers (parsers, networking helpers, common retry wrappers, \u2026).</li> <li><code>pyproject.toml</code> \u2014 Project metadata and entry-points so Boardfarm can discover the plugin.</li> </ul>"},{"location":"development/#pyprojecttoml-entry-point","title":"pyproject.toml (entry-point)","text":"<p>Boardfarm discovers plugins by loading setuptools/PEP-621 entry-points in the <code>boardfarm</code> group.</p> <p>Here's an example <code>pyproject.toml</code> (replace <code>&lt;plugin_name&gt;</code> with your package name \u2014 example below uses <code>boardfarm_plugin_a</code>):</p> <pre><code>[project]\nname = \"boardfarm_plugin_a\"\nversion = \"0.0.1\"\ndescription = \"Boardfarm plugin with Device A\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.11\"\nauthors = [\n  { name = \"Ketone\", email = \"devs@ketone.example\" }\n]\n\n[project.entry-points.\"boardfarm\"]\n# the importable module path that contains your @hookimpl functions\nboardfarm_plugin = \"boardfarm_plugin_a.plugins.registration\"\n</code></pre> <p>Template (Generic):</p> <pre><code>[project]\nname = \"boardfarm_&lt;plugin_name&gt;\"\n...\n[project.entry-points.\"boardfarm\"]\nboardfarm_plugin = \"boardfarm_&lt;plugin_name&gt;.plugins.registration\"\n\n</code></pre> <p>Notes:</p> <ul> <li><code>boardfarm_plugin</code> is an arbitrary key \u2014 Boardfarm will load the value (plugin module) in the <code>boardfarm</code> entry-point group.</li> <li>Ensure your package name and entry-point module are importable when the package is installed.</li> </ul>"},{"location":"development/#making-your-plugin-discoverable","title":"Making your plugin discoverable","text":"<p>From your project root, install the package (use editable option during development):</p> <pre><code>pip install -e .\n</code></pre> <p>This registers the <code>boardfarm</code> entry-point for your package in the current environment so <code>plugin_manager.load_setuptools_entrypoints(\"boardfarm\")</code> can find it. This way the runner registers the @hookimpl functions with the Pluggy PluginManager.</p> <p>After loading:</p> <ul> <li>Boardfarm may call your core hooks (e.g., <code>boardfarm_add_cmdline_args</code>) during runner setup.</li> <li>The runner uses <code>boardfarm_add_devices()</code> mapping to know which concrete classes correspond to inventory \"type\" values.</li> </ul>"},{"location":"development/#writing-a-device-class","title":"Writing a Device class","text":""},{"location":"development/#minimal-plugin-example","title":"Minimal plugin example","text":"<p>Create <code>plugins/registration.py</code> and implement <code>@hookimpl</code> functions. Keep core hooks module-level and device hooks as <code>@hookimpl</code> instance methods inside device classes in <code>devices/</code>.</p>"},{"location":"development/#pluginregistrationpy","title":"<code>plugin/registration.py</code>","text":"<pre><code># plugins/registration.py\nfrom boardfarm3 import hookimpl\nfrom boardfarm3.devices.base_devices import BoardfarmDevice\nfrom boardfarm_&lt;plugin_name&gt;.devices.device_a import DeviceA  # replace with your package\n\n@hookimpl\ndef boardfarm_add_devices() -&gt; dict[str, type[BoardfarmDevice]]:\n    \"\"\"Register the concrete device types this package provides.\"\"\"\n    return {\n        \"device_a\": DeviceA,\n    }\n\n@hookimpl\ndef boardfarm_add_cmdline_args(argparser):\n    argparser.add_argument(\"--devicea-debug\", action=\"store_true\", help=\"Enable DeviceA plugin debug\")\n\n</code></pre>"},{"location":"development/#templatesdevicepy-skeleton","title":"<code>templates/device.py</code> (Skeleton)","text":"<pre><code># templates/device.py\nfrom abc import ABC, abstractmethod\n\nclass DevA(ABC):\n    \"\"\"Minimal template for DeviceA-style devices.\n\n    Implementations must provide `method_x`. Use cases and tests should\n    depend on this ABC, not concrete classes.\n    \"\"\"\n\n    @abstractmethod\n    def method_x(self, payload=None, timeout=None):\n        \"\"\"Perform method_x on the device.\n\n        :param payload: optional input data\n        :param timeout: optional timeout in seconds\n        :return: result (implementation-specific)\n        \"\"\"\n        raise NotImplementedError\n\n</code></pre>"},{"location":"development/#devicesdevice_apy-skeleton","title":"<code>devices/device_a.py</code> (Skeleton)","text":"<pre><code># devices/device_a.py\nfrom boardfarm3 import hookimpl\nfrom boardfarm3.devices.base_devices import LinuxDevice\nfrom boardfarm_plugin_a.templates.device import DevA\n\nclass DeviceA(LinuxDevice, DevA):\n    def __init__(self, config, cmdline_args):\n        super().__init__(config, cmdline_args)\n        # initialization...\n\n    def method_x(self, payload=None, timeout=None):\n        \"\"\"Concrete implementation of the template method.\"\"\"\n        # do device interaction (SSH/HTTP/console/etc.)\n        return {\"status\": \"ok\", \"payload\": payload}\n\n    @hookimpl\n    def boardfarm_server_boot(self):\n        self._connect()\n        # any init steps\n\n    @hookimpl\n    def contingency_check(self, env_req, device_manager=None):\n        # raise ContingencyCheckError on failure, or return None on success\n        pass\n</code></pre> <p>Why instance methods for device hooks?</p> <p>Device hooks often require access to device instance state (console, HTTP client, config). Decorating instance methods with @hookimpl allows the runner to call the method on the instantiated device object.</p>"},{"location":"development/#inventory-example-for-devicea","title":"Inventory example for <code>DeviceA</code>","text":"<p>Boardfarm looks up the <code>type</code> value from the inventory and instantiates the registered class (e.g. <code>DeviceA</code>) for that entry. The root-level key in this example is <code>plugin-a-board1</code> and it contains a <code>devices</code> list.</p> <pre><code>{\n  \"plugin-a-board1\": {\n    \"devices\": [\n      {\n        \"name\": \"devicea-1\",\n        \"type\": \"device_a\",\n        \"connection_type\": \"authenticated_ssh\",\n        \"ipaddr\": \"192.168.1.10\",\n        \"port\": 22,\n        \"username\": \"root\",\n        \"password\": \"changeme\",\n        \"options\": \"some-option,other-flag\",\n        \"color\": \"blue\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"development/#runtime-behavior","title":"Runtime behavior","text":"<ul> <li>At setup the runner passes the device entry (the full dict) into the device constructor: <code>DeviceA(config_for_entry, cmdline_args)</code>.</li> <li>Device implementations should read required fields from their <code>config</code> (e.g. <code>self._config.get(\"ipaddr\")</code>) and raise a clear error if required keys are missing.</li> <li>If your driver needs additional inventory keys (serial, product_class, oui, vlans, etc.), document them in your plugin README and validate them in <code>validate_device_requirements</code> or during device instantiation.</li> </ul>"},{"location":"development/#writing-a-connection-class","title":"Writing a Connection class","text":""},{"location":"development/#connection-layer-transport-vs-device-logic","title":"Connection layer (transport vs device logic)","text":"<p>Boardfarm separates transport (how you talk to a device) from device logic (what you do with the device). The connection layer (classes like <code>SSHConnection</code>, <code>TelnetConnection</code>, <code>LocalCmd</code>, etc.) implements a small, consistent console API (based on <code>BoardfarmPexpect</code>) that device implementations use to execute commands, read output, and perform interactive tasks.</p> <p>The <code>connection_factory(...)</code> centralizes creating the right connection object based on the inventory <code>connection_type</code> and parameters. Devices call the factory, get back a <code>BoardfarmPexpect</code>-derived object, and use its methods (<code>sendline</code>, <code>expect</code>, <code>execute_command</code>, <code>get_last_output</code>, async variants, etc.) \u2014 the device code does not need to know whether the transport is SSH, serial, telnet or a <code>docker exec</code>-style local command.</p>"},{"location":"development/#benefits","title":"Benefits","text":"<ul> <li>Transport abstraction \u2014 device code is written once; the transport can change without touching use-cases or device implementations.</li> <li>Consistent API \u2014 devices always call the same methods (sync/async) on the returned connection object.</li> <li>Centralized error handling &amp; logging \u2014 connection classes raise framework errors (<code>DeviceConnectionError</code>, <code>BoardfarmException</code>, <code>EnvConfigError</code>) and handle console-log saving in one place.</li> <li>Easier testing &amp; mocking \u2014 swap real connections for fakes/mocks implementing the same API.</li> <li>Extensibility \u2014 add new transports by implementing a connection class and registering it in <code>connection_factory</code>.</li> <li>Async support \u2014 many connection classes provide both sync and async methods (<code>login_to_server_async</code>, <code>execute_command_async</code>) for scalable parallel provisioning.</li> </ul>"},{"location":"development/#how-devices-use-it-typical-flow-_connect","title":"How devices use it \u2014 typical flow (<code>_connect</code>)","text":"<p>A device usually implements a <code>_connect()</code> helper that:</p> <ol> <li>Calls <code>connection_factory(...)</code> with <code>connection_type</code> and connection params from the <code>inventory</code> JSON entry.</li> <li>Calls <code>login_to_server(...)</code> (or <code>login_to_server_async(...)</code>) to complete authentication.</li> <li>Normalizes the terminal (for example <code>stty columns 400; export TERM=xterm</code>) to make command output parsing stable.</li> </ol>"},{"location":"development/#compact-example-_connect-method-for-device-a","title":"Compact example (<code>_connect</code> method for device A)","text":"<pre><code>def _connect(self) -&gt; None:\n    \"\"\"Establish connection to the device via SSH (or other transport).\"\"\"\n    if self._console is None:\n        # create the right connection object based on inventory\n        self._console = connection_factory(\n            self._config.get(\"connection_type\"), # check INV JSON\n            f\"{self.device_name}.console\",\n            ... # remaining args\n        )\n\n        # perform authentication (sync or async variant)\n        self._console.login_to_server(password=self._password)\n\n        # stabilize terminal for predictable parsing\n        self._console.execute_command(\"stty columns 400; export TERM=xterm\")\n</code></pre>"},{"location":"development/#notes-tips","title":"Notes / tips","text":"<ul> <li>Use <code>connection_factory</code> rather than creating transport objects directly \u2014 it keeps device code portable and consistent.</li> <li>Prefer high-level helpers like <code>execute_command()</code> unless you need fine-grained <code>expect()</code> control. High-level helpers handle prompt/timeout edge cases for you.</li> <li>Validate required inventory fields (<code>ipaddr</code>, <code>port</code>, <code>username</code>, etc.) during device construction or in <code>validate_device_requirements</code> so failures are detected early.</li> <li>Use async methods for concurrency: if your device supports asyncio and you implement <code>*_async</code> hooks, call <code>login_to_server_async()</code> and <code>execute_command_async()</code> to avoid blocking other provisioning tasks.</li> </ul>"},{"location":"development/#writing-a-use-case","title":"Writing a Use Case","text":"<p>This short how-to shows a small use case that provisions a <code>DeviceA</code>-style device by calling the templated API <code>method_x</code>. The use case depends only on the template (ABC) \u2014 <code>DevA</code> \u2014 not on any concrete implementation. This keeps tests and scripts vendor-agnostic.</p> <p>File: <code>use_cases/provisioning.py</code></p> <pre><code># use_cases/provisioning.py\nfrom __future__ import annotations\nfrom typing import Any\n\n# import the template/ABC, not a concrete class\nfrom boardfarm_plugin_a.templates.device import DevA\n\n\ndef provision_device(\n    device: DevA,\n    config: dict[str, Any] | None = None,\n    timeout: int | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Provision a DeviceA-style device.\"\"\"\n    payload = config or {\"action\": \"default_provision\"}\n\n    # call the templated API\n    # concrete DeviceA (or any other implementation)\n    # will perform the actual transport/IO\n    result = device.method_x(payload=payload, timeout=timeout)\n\n    # basic validation of result (example)\n    if not isinstance(result, dict) or result.get(\"status\") != \"ok\":\n        raise RuntimeError(f\"Provisioning failed: {result}\")\n\n    return result\n</code></pre>"},{"location":"development/#example-usage","title":"Example Usage","text":""},{"location":"development/#interactive-shell-ipython","title":"Interactive Shell (IPython)","text":"<pre><code>from boardfarm_plugin_a.templates.device import DevA\nfrom boardfarm3.lib.device_manager import DeviceManager\nfrom boardfarm_plugin_a.use_cases.provisioning import provision_device\n\n# device_manager is provided by the runner / interact session\ndevice: DevA = device_manager.get_device_by_type(DevA)\nresult = provision_device(device, config={\"action\": \"apply_profile\", \"profile\": \"A1\"})\nprint(result)\n\n</code></pre>"},{"location":"development/#pytest-example","title":"Pytest Example","text":"<pre><code>def test_provision_device(device_manager):\n    device = device_manager.get_device_by_type(DevA)\n    res = provision_device(device, {\"action\": \"apply_profile\", \"profile\": \"CI\"}, timeout=60)\n    assert res[\"status\"] == \"ok\"\n\n</code></pre>"},{"location":"development/#design-notes-best-practices","title":"Design notes &amp; best practices","text":"<ul> <li>Type hints use the template (ABC) \u2014 <code>DevA</code> \u2014 so the use case is independent of concrete drivers.</li> <li>Keep use cases small and focused \u2014 orchestration and business logic belong here; transport and vendor quirks remain in device implementations.</li> <li>Propagate errors so tests/runner can handle retries or fail fast. Optionally use retry helpers (e.g. <code>retry_on_exception</code>) for transient operations.</li> <li>Return a stable structure (e.g. <code>{\"status\": \"ok\", \"data\": {...}}</code>) so callers can assert on consistent fields across vendors.</li> <li>Document expected payload keys for <code>config</code> in the plugin README so integrators know which fields a concrete <code>DeviceA</code> expects.</li> </ul> <p>Tip \u2014 use-cases are business logic, name them by protocol/behavior, not by device type. In networking, prefer protocol- or feature-oriented names for use case modules (for example <code>use_cases/tr069.py</code> for ACS/TR-069 operations) rather than <code>use_cases/acs_device.py</code>. Templates abstract device types \u2014 use case names should reflect the business operation (e.g. <code>tr069</code>, <code>dhcp_provision</code>, <code>firmware_flash</code>) so they remain meaningful across different implementations.</p>"},{"location":"getting_started/","title":"Getting Started with Boardfarm","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>Depending on your distribution you need some dependencies. On Debian these usually are:</p> <pre><code>sudo apt install -y automake libtool libsnmp-dev bison make gcc flex git libglib2.0-dev libfl-dev python3.13-venv\n</code></pre> <p>It is recommended to install boardfarm in a virtualenv:</p> <pre><code>python3.13 -m venv --prompt bf-venv venv\nsource venv/bin/activate\npip install --upgrade pip wheel\n</code></pre>"},{"location":"getting_started/#install-latest-release","title":"Install Latest Release","text":"<pre><code>(bf-venv)$ pip install boardfarm\n</code></pre>"},{"location":"getting_started/#install-development-build","title":"Install Development Build","text":"<p>Start by cloning the repository and installing boardfarm:</p> <pre><code>(bf-venv)$ git clone https://github.com/lgirdk/boardfarm\n(bf-venv)$ cd boardfarm &amp;&amp; pip install -e .[doc,dev,test]\n</code></pre> <p>Note: For certain boardfarm plugin packages like <code>boardfarm[docsis]</code>, additional tools need to be installed as prerequisite. e.g. DOCSIS bootfile encoder tool</p>"},{"location":"getting_started/#running-an-interactive-session","title":"Running an interactive session","text":"<p>Interact is a key feature in boardfarm that connects to every device currently deployed in a testbed and exposes a menu-driven CLI to interact with any of those devices. Every console interaction can be preserved in per-device log files.</p> <p>Boardfarm also provides an interactive IPython console that enables a user to execute commands on their devices via their corresponding Python APIs.</p>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":""},{"location":"getting_started/#1-no-hardware-testbed-try-a-virtual-environment","title":"1. No hardware testbed? Try a virtual environment","text":"<p>In case you don\u2019t have access to a physical testbed, we have a Docker Compose script that spins up a virtual CPE (PrplOS) with a back-office. This lets you explore interact sessions and device APIs locally on your workstation.</p> <p>More details can be found in the raikou-net project if you\u2019re interested in a more complete and in depth virtualized setup. To quickly deploy a local environment, run:</p> <pre><code># Assuming boardfarm repo is already cloned\n\ncd resources/deploy/prplos\ndocker compose up -f docker-compose.yaml -d\n</code></pre> <p>Note: If you want to explore more examples, see <code>/examples/double_hop</code> directory in raikou-net</p>"},{"location":"getting_started/#2-understanding-inventory-and-environment-files","title":"2. Understanding Inventory and Environment files","text":"<p>Boardfarm needs two configuration files to know what to deploy and how to interact with it:</p> <ol> <li> <p>Inventory file (<code>inventory.json</code>)</p> <ul> <li>Describes the devices in your testbed and how Boardfarm connects to them.</li> <li>Each device entry specifies:<ul> <li>connection type (serial, ssh, docker exec, etc.)</li> <li>login credentials / ports / proxies</li> <li>role/type (CPE, WAN, LAN, ACS, DHCP, SIP server, phones, etc.)</li> <li>options that customize network behavior (e.g., static IPs, DHCP off/on, DNS, VLAN).</li> </ul> </li> <li>Think of it as a map of your deployed infrastructure and the \u201cdoorways\u201d Boardfarm can use to reach each device.</li> </ul> <p>Example (excerpt taken from <code>boardfarm3/configs/boardfarm_config_example.json</code>):</p> <p><code>json {     \"prplos-docker-1\": {     \"devices\": [         {         \"conn_cmd\": [\"docker exec -it cpe ash\"],         \"connection_type\": \"local_cmd\",         \"name\": \"board\",         \"type\": \"bf_cpe\",         \"gui_password\": \"admin\"         },         {         \"connection_type\": \"authenticated_ssh\",         \"ipaddr\": \"localhost\",         \"port\": 4001,         \"name\": \"wan\",         \"type\": \"bf_wan\",         \"options\": \"wan-no-dhcp-server, dns-server, wan-static-ip:172.25.1.2/24\"         }         // ... more devices like lan, acs, phones, provisioner, etc.     ]     } }</code></p> <p>In this setup, the board is reached through a local Docker exec command, while WAN, LAN, ACS, and phones are accessed via SSH on different forwarded ports.</p> <p>Please see Inventory Schema for a list of all possible options that can be configured for a device in an Inventory file.</p> </li> <li> <p>Environment file (<code>env.json</code>)</p> <ul> <li>Tells Boardfarm how to provision the testbed once devices are connected.</li> <li>Defines higher-level testbed behavior and requirements, such as:<ul> <li>Which firmware to flash on the board/CPE</li> <li>How DHCP should behave (options, VLANs, DNS)</li> <li>Whether to create multiple LAN/WLAN containers</li> <li>How subscriber configurations look if an LTS (Line Termination System) is present</li> <li>Other provisioning knobs (IPv4/IPv6 mode, model identifiers, etc.)</li> </ul> </li> </ul> <p>Example (simple):</p> <p><code>json {     \"environment_def\": {     \"board\": {         \"eRouter_Provisioning_mode\": \"ipv4\",         \"model\": \"prplOS\"     }     } }</code></p> </li> <li> <p>How they work together?</p> <p>Inventory = \u201cwhat\u2019s there\u201d - A catalog of devices, connection methods, roles.</p> <p>Environment = \u201cwhat to do with it\u201d - Provisioning rules, firmware flashing, DHCP setup, network topology.</p> <p>This tells Boardfarm:</p> <p>Connect to all devices listed in the inventory. Provision and configure them according to the environment definition. Expose them via the interact session (menu + IPython).</p> </li> </ol>"},{"location":"getting_started/#start-an-interact-session","title":"Start an interact session","text":"<p>Now that we have our environment and inventory files, we can start an interactive session with Boardfarm.</p> <pre><code>boardfarm --board-name  prplos-docker-1 \\\n    --env-config ./boardfarm3/configs/boardfarm_env_example.json \\\n    --inventory-config ./boardfarm3/configs/boardfarm_config_example.json \\\n    --skip-boot --legacy\n</code></pre> <p>(Optional) --save-console-logs enabled to persist console logs to disk.</p> <p>This will bring up the Boardfarm Interactive Shell, where all deployed devices are listed and ready for interaction. </p> <p>When you see this menu:</p> <pre><code>                BOARDFARM INTERACTIVE SHELL\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  Choice   Description                           Consoles\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    1      board (bf_cpe)                           1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    2      genieacs (bf_acs)                        1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    3      lan (bf_lan)                             1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    4      lan_phone (bf_phone)                     1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    5      provisioner (bf_dhcp)                    1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    6      sipcenter (bf_kamailio)                  1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    7      wan (bf_wan)                             1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    8      wan_phone (bf_phone)                     1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    p      python interactive shell (ptpython)\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    q      exit\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnter your choice: [1/2/3/4/5/6/7/8/p/q]:\n</code></pre> <p>You have two main options:</p> <ul> <li> <p>Device console access \u2192 enter the number (1\u20138) beside a device to drop directly into its console session.</p> </li> <li> <p>Python interactive shell \u2192 enter <code>p</code> to open an IPython-like interface (ptpython) where you can import devices and call their Python APIs to run commands or tests programmatically.</p> </li> </ul> <p>This makes it easy to switch between manual console exploration and Python-based automation in the same session.</p>"},{"location":"getting_started/#booting-up-a-lab-environment","title":"Booting up a lab environment","text":"<p>In the previous example, we started Boardfarm with the <code>--skip-boot</code> option to quickly attach to already running devices. If we remove the <code>--skip-boot</code> option, Boardfarm will not just connect to devices \u2014 it will also provision them based on the environment file you provided.</p> <p>Behind the scenes, Boardfarm uses Pluggy (the same plugin system used by pytest). This means that devices participate in different lifecycle phases by implementing specific plugin hooks.</p>"},{"location":"getting_started/#bootprovisioning-hooks","title":"Boot/Provisioning Hooks","text":"<p>When boot is not skipped, Boardfarm\u2019s plugin manager executes the following hooks in order:</p> <pre><code>boardfarm_server_boot\n\u2193\nboardfarm_server_configure\n\u2193\nboardfarm_device_boot\n\u2193\nboardfarm_device_configure\n\u2193\nboardfarm_attached_device_boot\n\u2193\nboardfarm_attached_device_configure\n</code></pre> <p>Each of the above is an actual <code>@hookspec</code> that a device class can implement. If a registered device provides an implementation, it will participate in that phase of booting/provisioning.</p> <ul> <li>Server hooks (<code>boardfarm_server_*</code>) \u2192 for back office infrastructure or virtualized service containers (e.g., DHCP, DNS, WAN, ACS, SIP servers).</li> <li>Device hooks (<code>boardfarm_device_*</code>) \u2192 for the main CPE/board a.k.a DUT.</li> <li>Attached device hooks (<code>boardfarm_attached_device_*</code>) \u2192 for LAN/WLAN clients, phones, or other peripherals that can only be provisioned once the main board is up.</li> </ul> <p>This layered boot sequence ensures that back-office infrastructure services are available before devices boot, and devices are provisioned before attached clients are configured.</p> <p>Please have a look at the boardfarm hooks section for more details.</p>"},{"location":"getting_started/#tldr","title":"TLDR","text":"<pre><code>git clone -b boardfarm3 https://github.com/lgirdk/boardfarm.git\ncd boardfarm\n\ncd resources/deploy/prplos\ndocker-compose up -f docker-compose.yaml -d\ndocker ps # make sure the containers are up and running\n\ncd - # go back to the boardfarm repo root dir\n\npython3.13 -m venv --prompt bf-venv venv # will work on 3.11 as well\nsource venv/bin/activate\n\npip install -U pip wheel\npip install -e .[dev,test,doc]\n\nboardfarm --board-name  prplos-docker-1 \\\n          --env-config ./boardfarm3/configs/boardfarm_env_example.json \\\n          --inventory-config ./boardfarm3/configs/boardfarm_config_example.json \\\n          --save-console-logs ./logs\n</code></pre>"}]}